import { BotContext } from '../bot';
import { CONFIG } from '../config';
import { prisma } from '../utils/database';
import { container } from 'tsyringe';
import { RatingService } from '../services/rating.service';

export const addHistoryCommand = async (ctx: BotContext): Promise<void> => {
  try {
    if (!CONFIG.ADMINS.includes(ctx.from!.id)) {
      await ctx.reply('üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ');
      return;
    }

    const text = ('text' in ctx.message! && ctx.message.text) ? ctx.message.text : '';

    if (!text.includes('\n')) {
      await ctx.reply(
        `üìã <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –º–∞—Ç—á–µ–π:</b>\n\n` +
        `–û—Ç–ø—Ä–∞–≤—å—Ç–µ /add_history, –∑–∞—Ç–µ–º —Å–ø–∏—Å–æ–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:\n` +
        `week/year winner_team score loser_team\n` +
        `winner1,winner2,winner3,winner4,winner5,winner6,winner7,winner8\n` +
        `loser1,loser2,loser3,loser4,loser5,loser6,loser7,loser8\n\n` +
        `<b>–ü—Ä–∏–º–µ—Ä:</b>\n` +
        `/add_history\n` +
        `30/2024 A 5-3 B\n` +
        `user1,user2,user3,user4,user5,user6,user7,user8\n` +
        `user9,user10,user11,user12,user13,user14,user15,user16\n\n` +
        `–ò–ª–∏ –ø—Ä–æ—Å—Ç–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –±–µ–∑ –∫–æ–º–∞–Ω–¥ (–æ–±–Ω–æ–≤–∏—Ç –≤—Å–µ—Ö —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ —Ç–µ–∫—É—â–µ–π –Ω–µ–¥–µ–ª–∏):\n` +
        `/add_history\n` +
        `32/2024 A 7-2 B`
      , { parse_mode: 'HTML' });
      return;
    }

    const lines = text.split('\n').slice(1);
    const results: string[] = [];
    let processed = 0;
    let errors = 0;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      if (!line) continue;

      try {
        // –ü–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: week/year team score team
        const resultMatch = line.match(/^(\d+)\/(\d+)\s+([AB])\s+(\d+)-(\d+)\s+([AB])$/);

        if (!resultMatch) {
          results.push(`‚ùå ${line} - –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞`);
          errors++;
          continue;
        }

        const [, weekStr, yearStr, team1, score1Str, score2Str, team2] = resultMatch;
        const week = parseInt(weekStr);
        const year = parseInt(yearStr);
        const score1 = parseInt(score1Str);
        const score2 = parseInt(score2Str);

        if (team1 === team2) {
          results.push(`‚ùå –ù–µ–¥–µ–ª—è ${week}/${year} - –∫–æ–º–∞–Ω–¥—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ä–∞–∑–Ω—ã–º–∏`);
          errors++;
          continue;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Å–ª–µ–¥—É—é—â–∏–µ 2 —Å—Ç—Ä–æ–∫–∏ —Å–æ —Å–ø–∏—Å–∫–∞–º–∏ –∏–≥—Ä–æ–∫–æ–≤
        let teamAPlayers: number[] = [];
        let teamBPlayers: number[] = [];

        if (i + 2 < lines.length && lines[i + 1].includes(',') && lines[i + 2].includes(',')) {
          // –ï—Å—Ç—å —Å–ø–∏—Å–∫–∏ –∏–≥—Ä–æ–∫–æ–≤
          const winnersLine = lines[i + 1].trim();
          const losersLine = lines[i + 2].trim();

          const winnerUsernames = winnersLine.split(',').map(u => u.trim().replace('@', ''));
          const loserUsernames = losersLine.split(',').map(u => u.trim().replace('@', ''));

          // –ò—â–µ–º –∏–≥—Ä–æ–∫–æ–≤ –ø–æ username
          const winnerPlayers = await prisma.player.findMany({
            where: { username: { in: winnerUsernames } }
          });
          console.log(winnerPlayers)
          const loserPlayers = await prisma.player.findMany({
            where: { username: { in: loserUsernames } }
          });
          console.log(winnerPlayers.length, winnerUsernames.length, loserPlayers.length, loserUsernames.length)

          if (winnerPlayers.length !== winnerUsernames.length || loserPlayers.length !== loserUsernames.length) {
            const notFoundWinners = winnerUsernames.filter(u => !winnerPlayers.some(p => p.username === u));
            const notFoundLosers = loserUsernames.filter(u => !loserPlayers.some(p => p.username === u));

            let errorMsg = `‚ùå –ù–µ–¥–µ–ª—è ${week}/${year} - –∏–≥—Ä–æ–∫–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã:`;
            if (notFoundWinners.length > 0) errorMsg += ` –ø–æ–±–µ–¥–∏—Ç–µ–ª–∏: ${notFoundWinners.join(', ')}`;
            if (notFoundLosers.length > 0) errorMsg += ` –ø—Ä–æ–∏–≥—Ä–∞–≤—à–∏–µ: ${notFoundLosers.join(', ')}`;

            results.push(errorMsg);
            errors++;
            i += 2; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–µ —Å—Ç—Ä–æ–∫–∏ —Å –∏–≥—Ä–æ–∫–∞–º–∏
            continue;
          }

          teamAPlayers = score1 > score2 ? winnerPlayers.map(p => p.id) : loserPlayers.map(p => p.id);
          teamBPlayers = score1 > score2 ? loserPlayers.map(p => p.id) : winnerPlayers.map(p => p.id);

          i += 2; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±–µ —Å—Ç—Ä–æ–∫–∏ —Å –∏–≥—Ä–æ–∫–∞–º–∏
        } else {
          // –ù–µ—Ç —Å–ø–∏—Å–∫–æ–≤ –∏–≥—Ä–æ–∫–æ–≤ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∏–≥—Ä–æ–∫–æ–≤ –∏–∑ —Ç–æ–π –Ω–µ–¥–µ–ª–∏
          const weekPlayers = await prisma.weekEntry.findMany({
            where: { week, year, state: 'MAIN' },
            include: { player: true },
            orderBy: { createdAt: 'asc' }
          });

          if (weekPlayers.length !== 16) {
            results.push(`‚ùå –ù–µ–¥–µ–ª—è ${week}/${year} - –Ω–∞–π–¥–µ–Ω–æ ${weekPlayers.length} –∏–≥—Ä–æ–∫–æ–≤ –≤–º–µ—Å—Ç–æ 16`);
            errors++;
            continue;
          }

          teamAPlayers = weekPlayers.slice(0, 8).map(entry => entry.playerId);
          teamBPlayers = weekPlayers.slice(8, 16).map(entry => entry.playerId);
        }

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–±–µ–¥–∏—Ç–µ–ª–µ–π –∏ –ø—Ä–æ–∏–≥—Ä–∞–≤—à–∏—Ö
        const ratingService = container.resolve(RatingService);

        if (score1 > score2) {
          const winners = team1 === 'A' ? teamAPlayers : teamBPlayers;
          const losers = team1 === 'A' ? teamBPlayers : teamAPlayers;
          await ratingService.updateTrueSkill(winners, losers);
        } else if (score2 > score1) {
          const winners = team2 === 'A' ? teamAPlayers : teamBPlayers;
          const losers = team2 === 'A' ? teamBPlayers : teamAPlayers;
          await ratingService.updateTrueSkill(winners, losers);
        }

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –º–∞—Ç—á–∞
        await prisma.gameSession.upsert({
          where: { week_year: { week, year } },
          update: {
            teamA: team1 === 'A' ? `${score1}` : `${score2}`,
            teamB: team1 === 'B' ? `${score1}` : `${score2}`,
            isConfirmed: true,
          },
          create: {
            week,
            year,
            teamA: team1 === 'A' ? `${score1}` : `${score2}`,
            teamB: team1 === 'B' ? `${score1}` : `${score2}`,
            isConfirmed: true,
          },
        });

        results.push(`‚úÖ –ù–µ–¥–µ–ª—è ${week}/${year}: ${team1} ${score1}-${score2} ${team2}`);
        processed++;

      } catch (error) {
        results.push(`‚ùå ${line} - –æ—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏: ${error}`);
        errors++;
      }
    }

    let message = `üìä <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –º–∞—Ç—á–µ–π:</b>\n\n`;
    message += `‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: ${processed}\n`;
    message += `‚ùå –û—à–∏–±–æ–∫: ${errors}\n\n`;

    if (results.length > 0) {
      message += `<b>–î–µ—Ç–∞–ª–∏:</b>\n${results.slice(0, 15).join('\n')}`;

      if (results.length > 15) {
        message += `\n... –∏ –µ—â–µ ${results.length - 15} –∑–∞–ø–∏—Å–µ–π`;
      }
    }

    await ctx.reply(message, { parse_mode: 'HTML' });

  } catch (error) {
    console.error('Error in add history command:', error);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.');
  }
};

export const bulkRateCommand = async (ctx: BotContext): Promise<void> => {
  try {
    if (!CONFIG.ADMINS.includes(ctx.from!.id)) {
      await ctx.reply('üö´ –£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥–µ');
      return;
    }

    const text = ('text' in ctx.message! && ctx.message.text) ? ctx.message.text : '';

    if (!text.includes('\n')) {
      await ctx.reply(
        `üìã <b>–ú–∞—Å—Å–æ–≤–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–æ–≤:</b>\n\n` +
        `–û—Ç–ø—Ä–∞–≤—å—Ç–µ /bulk_rate, –∑–∞—Ç–µ–º —Å–ø–∏—Å–æ–∫:\n` +
        `username rating_change\n\n` +
        `<b>–ü—Ä–∏–º–µ—Ä:</b>\n` +
        `/bulk_rate\n` +
        `user1 +1\n` +
        `user2 +1\n` +
        `user3 0\n` +
        `user4 -1`
      , { parse_mode: 'HTML' });
      return;
    }

    const lines = text.split('\n').slice(1);
    const results: string[] = [];
    let processed = 0;
    let errors = 0;

    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine) continue;

      try {
        const parts = trimmedLine.split(/\s+/);
        if (parts.length !== 2) {
          results.push(`‚ùå ${trimmedLine} - –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç`);
          errors++;
          continue;
        }

        const username = parts[0].replace('@', '');
        const delta = parseInt(parts[1]);

        if (isNaN(delta) || delta < -1 || delta > 1) {
          results.push(`‚ùå @${username} - —Ä–µ–π—Ç–∏–Ω–≥ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å -1, 0 –∏–ª–∏ +1`);
          errors++;
          continue;
        }

        const player = await prisma.player.findFirst({
          where: { username }
        });

        if (!player) {
          results.push(`‚ùå @${username} - –∏–≥—Ä–æ–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω`);
          errors++;
          continue;
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–µ–π—Ç–∏–Ω–≥
        await prisma.player.update({
          where: { id: player.id },
          data: {
            skillCaptain: Math.max(0, Math.min(10, player.skillCaptain + delta)),
          },
        });

        await prisma.rating.create({
          data: {
            matchId: Math.floor(Date.now() / 1000),
            playerId: player.id,
            delta,
            scheme: 'captain',
          },
        });

        results.push(`‚úÖ @${username} - ${delta > 0 ? '+' : ''}${delta}`);
        processed++;

      } catch (error) {
        results.push(`‚ùå ${trimmedLine} - –æ—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏`);
        errors++;
      }
    }

    let message = `üìä <b>–†–µ–∑—É–ª—å—Ç–∞—Ç –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–µ–π—Ç–∏–Ω–≥–æ–≤:</b>\n\n`;
    message += `‚úÖ –û–±—Ä–∞–±–æ—Ç–∞–Ω–æ: ${processed}\n`;
    message += `‚ùå –û—à–∏–±–æ–∫: ${errors}\n\n`;

    if (results.length > 0) {
      message += `<b>–î–µ—Ç–∞–ª–∏:</b>\n${results.slice(0, 20).join('\n')}`;

      if (results.length > 20) {
        message += `\n... –∏ –µ—â–µ ${results.length - 20} –∑–∞–ø–∏—Å–µ–π`;
      }
    }

    await ctx.reply(message, { parse_mode: 'HTML' });

  } catch (error) {
    console.error('Error in bulk rate command:', error);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –º–∞—Å—Å–æ–≤–æ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Ä–µ–π—Ç–∏–Ω–≥–æ–≤.');
  }
};